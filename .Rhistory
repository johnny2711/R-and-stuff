help("cbind")
X <- cbind(rep(1, n), data[, c(2:(nvar))])
X <- cbind(rep(1, n), data[, c(2:(var))])
X <- cbind(rep(1, n), data[, c(2:(var))])
XT = t(X)
X <- cbind(rep(1, n), data[, c(2:var)])
X <- cbind(rep(1, n), data[, c(2:var)])
X <- cbind(c(rep(1,n),data[ ,c(2:var)])
XT = t(X)
X <- cbind(c(rep(1,n),data[ ,c(2:(var)])
X <- cbind(c(rep(1,n),data[ ,c(2:(var)]))
X <- cbind(rep(1,n),data[ ,c(2:(var)]))
X <- cbind(rep(1,n),data[,c(2:(var)]))
sample<- mvrnorm(N, mu = MU, Sigma = SIGMA)
N=50
sample<- mvrnorm(N, mu = MU, Sigma = SIGMA)
Y<- sample[, 1]
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
nvar=5
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
XT = t(X)
XTX = XT%*%X
sample<- mvrnorm(N, mu = MU, Sigma = SIGMA)
Y<- sample[, 1]
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
n <- 100
var <- 4
# MU and SIGMA are randomely chosen
MU<-runif(var, 1, 50)
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
reg <- function(n, MU, SIGMA){
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,50),X),ncol=var+1)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
beta
general_OLS<-function(nvar, #Number of variables
MU,   #Vector of means
SIGMA,#Variance-covariance matrix
N     #Sample size
){
#The following if statements enable parameters not to be given in the call
#of the function. If they are not given, a value is totally randomly
#attributed. For instance, the total number of variables is between
# 2 and 102.
if(is.na(nvar)){
nvar<-floor(runif(1,0,1)*100+2)
}
if(is.na(MU)){
MU<-runif(nvar, 5, 25)
}
#The definition of arbitrary variance-covariance matrix is a little bit
#technical, because it has to be symmetrical and positive definite.
#To do this, we "just" have to compute a random matrix X, and form the
#matrix X.t(X), which is positive definite and invertible.
if(is.na(SIGMA)){
coeff_sigma<- runif(nvar*nvar, 0, 1)
SIG<- matrix(coeff_sigma, ncol = nvar, nrow = nvar)
SIGMA<-SIG%*%t(SIG)
}
if(is.na(N)){
N<-floor(runif(1,0,1)*1000+5*nvar)
}
sample<- mvrnorm(N, mu = MU, Sigma = SIGMA)
Y<- sample[, 1]
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%Y
beta = invXTX %*% XTy
return(beta)
if(nvar == 2){
graph<-plot(sample)
abline(lm(sample[,2]~sample[,1]), col="red")
abline(a=beta[1], b=beta[2], col="blue")
}
#This part is not functional, there is only the idea
if(nvar == 3){
library(plot3D)
graph<-persp3D(x = sample[, 2], y = sample[, 3], z = sample[, 1], colvar = z)
}
return(graph)
}
beta
rm(list=ls())
#Here we have the choice for the parameters of the function that we call
#general_OLS(). As it it asked to the function to take arbitrary parameters,
#we could consider that it computes them itself. However, we let an option
#if we want to define some parameters.
general_OLS<-function(nvar, #Number of variables
MU,   #Vector of means
SIGMA,#Variance-covariance matrix
N     #Sample size
){
#The following if statements enable parameters not to be given in the call
#of the function. If they are not given, a value is totally randomly
#attributed. For instance, the total number of variables is between
# 2 and 102.
if(is.na(nvar)){
nvar<-floor(runif(1,0,1)*100+2)
}
if(is.na(MU)){
MU<-runif(nvar, 5, 25)
}
#The definition of arbitrary variance-covariance matrix is a little bit
#technical, because it has to be symmetrical and positive definite.
#To do this, we "just" have to compute a random matrix X, and form the
#matrix X.t(X), which is positive definite and invertible.
if(is.na(SIGMA)){
coeff_sigma<- runif(nvar*nvar, 0, 1)
SIG<- matrix(coeff_sigma, ncol = nvar, nrow = nvar)
SIGMA<-SIG%*%t(SIG)
}
if(is.na(N)){
N<-floor(runif(1,0,1)*1000+5*nvar)
}
sample<- mvrnorm(N, mu = MU, Sigma = SIGMA)
Y<- sample[, 1]
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%Y
beta = invXTX %*% XTy
return(beta)
if(nvar == 2){
graph<-plot(sample)
abline(lm(sample[,2]~sample[,1]), col="red")
abline(a=beta[1], b=beta[2], col="blue")
}
#This part is not functional, there is only the idea
if(nvar == 3){
library(plot3D)
graph<-persp3D(x = sample[, 2], y = sample[, 3], z = sample[, 1], colvar = z)
}
return(graph)
}
beta
print(beta)
general_OLS(nvar = 2, MU = NA, SIGMA = NA, N = NA)
reg
n <- 100
var <- 4
# MU and SIGMA are randomely chosen
MU<-runif(var, 1, 50)
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
reg <- function(n, MU, SIGMA){
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var+1)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg
reg(n=50,mu=MU,Sigma=SIGMA)
reg(n=50)
reg(n=50, MU=MU, SIGMA=SIGMA)
beta
n <- 100
var <- 4
# MU and SIGMA are randomely chosen
MU<-runif(var, 1, 50)
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
reg <- function(n, MU, SIGMA){
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var+1)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
beta
reg(n=50,mu=MU,Sigma=SIGMA)
n <- 100
var <- 4
MU<-runif(var, 1, 50)
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var+1)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg(n=50,MU=,Sigma=SIGMA)
reg(n=50,MU=NA,Sigma=NA)
reg(n=50,MU=NA,SIGMA=NA)
beta
reg(n=50,MU=NA,SIGMA=NA)
reg(n,MU=NA,SIGMA=NA)
reg(n=50, MU = NA, SIGMA = NA)
reg(n=50, MU = NA, SIGMA = NA)
beta
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var+1]
X <- matrix(c(rep(1,n),X),ncol=var+1)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg(n=50, MU = NA, SIGMA = NA)
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg(n=50, MU = NA, SIGMA = NA)
print(reg)
general_OLS<-function(nvar, #Number of variables
MU,   #Vector of means
SIGMA,#Variance-covariance matrix
N     #Sample size
){
#The following if statements enable parameters not to be given in the call
#of the function. If they are not given, a value is totally randomly
#attributed. For instance, the total number of variables is between
# 2 and 102.
if(is.na(nvar)){
nvar<-floor(runif(1,0,1)*100+2)
}
if(is.na(MU)){
MU<-runif(nvar, 5, 25)
}
#The definition of arbitrary variance-covariance matrix is a little bit
#technical, because it has to be symmetrical and positive definite.
#To do this, we "just" have to compute a random matrix X, and form the
#matrix X.t(X), which is positive definite and invertible.
if(is.na(SIGMA)){
coeff_sigma<- runif(nvar*nvar, 0, 1)
SIG<- matrix(coeff_sigma, ncol = nvar, nrow = nvar)
SIGMA<-SIG%*%t(SIG)
}
if(is.na(N)){
N<-floor(runif(1,0,1)*1000+5*nvar)
}
sample<- mvrnorm(N, mu = MU, Sigma = SIGMA)
Y<- sample[, 1]
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%Y
beta = invXTX %*% XTy
return(beta)
if(nvar == 2){
graph<-plot(sample)
abline(lm(sample[,2]~sample[,1]), col="red")
abline(a=beta[1], b=beta[2], col="blue")
}
#This part is not functional, there is only the idea
if(nvar == 3){
library(plot3D)
graph<-persp3D(x = sample[, 2], y = sample[, 3], z = sample[, 1], colvar = z)
}
return(graph)
}
general_OLS(nvar = 2, MU = NA, SIGMA = NA, N = NA)
reg(n=50, MU = NA, SIGMA = NA)
reg(50, MU = NA, SIGMA = NA)
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
if(is.na(n)){
n<-floor(runif(1,0,1)*1000+5*var)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg(n = NA, MU = NA, SIGMA = NA)
reg(n = NA, MU = NA, SIGMA = NA)
View(reg)
X<- cbind(rep(1, n), data[, c(2:(var))])
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
N=10
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
nvar=5
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
general_OLS<-function(nvar, #Number of variables
MU,   #Vector of means
SIGMA,#Variance-covariance matrix
N     #Sample size
){
#The following if statements enable parameters not to be given in the call
#of the function. If they are not given, a value is totally randomly
#attributed. For instance, the total number of variables is between
# 2 and 102.
sample<- mvrnorm(N, mu = MU, Sigma = SIGMA)
Y<- sample[, 1]
X<- cbind(rep(1, N), sample[, c(2:(nvar))])
XT = t(X)
XTX = XT%*%X
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X<- cbind(rep(1, n), data[, c(2:(var))])
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg(n = NA, MU = NA, SIGMA = NA)
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X<- cbind(rep(1, n), data[, c(2:(var))])
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
print(d)
}
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X<- cbind(rep(1, n), data[, c(2:(var))])
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X<- cbind(rep(1, n), data[, c(2:(var))])
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg(n = NA, MU = NA, SIGMA = NA)
reg(n = 50, MU = NA, SIGMA = NA)
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
}
reg(n = 50, MU = NA, SIGMA = NA)
n <- 100
var <- 4
reg <- function(n, MU, SIGMA){
# MU and SIGMA are randomely chosen unless specific values are assigned
if(is.na(MU)){
MU<-runif(var, 1, 50)
}
if(is.na(SIGMA)){
coeff_sigma<- runif(var*var, 0, 1)
SIG<- matrix(coeff_sigma, ncol = var, nrow = var)
SIGMA<-SIG%*%t(SIG)
}
data <- mvrnorm(n, mu = MU, Sigma = SIGMA)
y <- data[,1]
X <- data[, 2:var]
X <- matrix(c(rep(1,n),X),ncol=var)
XT = t(X)
XTX = XT%*%X
invXTX = solve(XTX)
XTy = XT%*%y
beta = invXTX %*% XTy
beta
}
reg(n = 50, MU = NA, SIGMA = NA)
install.packages("devtools")
install.packages("testthat")
install.packages("roxygen2")
